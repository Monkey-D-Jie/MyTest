package com.jf.mydemo.mytest.Thread.SomeExampleInLife.myThreadTest;

/**
 * @Author wangjie
 * @Date 2018-06-04 23:09
 * @Description 总测试类
 */
public class ThreadTest01 {
    public static void main(String[] args) {
        Resource resource = new Resource();
        Input input = new Input(resource);
        Output output = new Output(resource);
        Thread inputThread = new Thread(input);
        Thread outputThread = new Thread(output);
        inputThread.start();
        outputThread.start();
    }
    /**
     * 测试结果记录：
     * ①：未加入同步代码时，出现了错误的打印结果
     得到的人员类型为:rose----男男男男
     得到的人员类型为:rose----女女女女
     得到的人员类型为:rose----女女女女
     得到的人员类型为:张三----女女女女
     得到的人员类型为:张三----男男男男
     得到的人员类型为:张三----男男男男
     得到的人员类型为:rose----男男男男
     ---------
     如上所示，本该是rose-女，张三-男的打印结果，却出现了错乱的情况。
     分析原因：是线程安全的问题导致的
     更具体的说明：如上所示的结果，当代码执行到x=0的情况下进入到
     张三的赋值代码中，
     刚把name的值给到，跟着CPU就切换到输出线程上去了。所以就导致了张三-女的输出结果
     解决问题：共享的代码数据包括赋值的过程和打印输出的语句，所以需要在这两处加上同步
     多线程，要以操作同一个锁为前提（即同步互斥的原理），
     this(or同步函数)---这里是两个不同的类 outPut，input，对应的锁不同；
     object---同上，连个不同的类，创建的对象虽然名字相同，但它们并不是同一个；
     要保证是同一个，因为两个类都是需要在初始化时加入resource对象，所以可以把resource对象当作锁来使；
     ②：加上了同步锁后的测试结果：
     得到的资源类型为:张三----男男男男
     得到的资源类型为:张三----男男男男
     得到的资源类型为:张三----男男男男
     得到的资源类型为:张三----男男男男
     得到的资源类型为:张三----男男男男
     如上所示，最终得到的结果是这样的。。。
     这样虽然能保证 张三-男，rose-女的对应关系，但在输出上仍然还有欠妥的地方。
     都是一大坨，一大坨的来。。。。
     分析原因：在进入到赋值的代码段后，比如刚把【张三-男】的对象搞定了，跟着又CPU又切换到out线程了，此时输出，就是
     一连串的张三-男，rose-女与之同理。
     在连续的测试下，肯定会出现一连串【张三-男】，【rose-女】的情况。
     ③：一大串连续输出的结果并非我们想要的，我要的是能间隔输出的。怎么来做呢？又该？
        用线程间的通信卅！！！！等待唤醒机制----》对于等待都需要判断，定义条件。
        即 你来我往式的打印！
     方法：用notify和wait去搞定；
     就是 保障在input对resource对象赋值后，才由output对象输出（类似于生产者和消费者生产面包）
     测试结果：
     得到的资源类型为:张三----男男男男
     得到的资源类型为:rose----女女女女
     得到的资源类型为:张三----男男男男
     得到的资源类型为:rose----女女女女
     得到的资源类型为:张三----男男男男
     确实就是我希望得到的 间隔开来的效果，而且对应关系也是正确的。
     ④：代码重构
     今天有点晚了，明天还要上班，暂时就先休息了，明天继续。。。
     2018-06-05 00:18:45
     /**
      * @Author  wangjie
      * @Date    2018-06-05 23:16:06
     * 更新---》重构后的测试结果记录
     * 结果：
     *  rose-----女女女女
        张三-----男男男男
        rose-----女女女女
        张三-----男男男男
        rose-----女女女女
     跟之前的一个效果，说明代码重构成功！
     我这里出现错误的原因：再重构方法中又去执行了循环，导致了死锁和死循环。
     因而没能把数据打印出来。
     ⑤：更改为jdk 1.5+后的lock来实现
        1.获取lock，并在finally中释放lock；
        2.获取condition监视器对象，并在该对象上发起等待和通知(监视器和锁对象分开了，做事情更明确和灵活)
     测试结果：
        张三-----男男男男
        rose-----女女女女
        张三-----男男男男
        rose-----女女女女
        张三-----男男男男
     要注意，用了lock之后，就没有必要再去使用同步了。
     不然，因为使用了嵌套锁，会造成死锁的情况，，，

     */



}
